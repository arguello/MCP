#!/usr/bin/python -u
#
# recongnizer
#   Processes Records in the Commits table
#
#  Steps include linting, testing, then building
#

import os

os.environ.setdefault( "DJANGO_SETTINGS_MODULE", "mcp.settings" )

import sys
import logging
import json
from logging.handlers import SysLogHandler
from datetime import datetime
from django.utils.timezone import utc
from django.conf import settings

from mcp.Processor.models import QueueItem
from mcp.Project.models import Commit
from mcp.lib.Slack import Slack

PID_FILE = '/var/run/recoginzer.pid'
QUEUE_PRIORITY = 100

logging.basicConfig()
logger = logging.getLogger()
handler = SysLogHandler( address='/dev/log', facility=SysLogHandler.LOG_DAEMON )
handler.setFormatter( logging.Formatter( fmt='recognizer[%(process)d]: %(message)s' ) )
logger.addHandler( handler )
logging.info( 'Starting...' )
if '-v' in sys.argv:
  logger.setLevel( logging.DEBUG )
else:
  logger.setLevel( logging.INFO )

if os.path.exists( PID_FILE ):
  logging.error( 'pid file exists, bailing...' )
  sys.exit( 0 )

tmp = open( PID_FILE, 'w' )
tmp.write( '%s\n' % os.getpid() )
tmp.close()

slack = Slack( 'recognizer', settings.SITE_NAME, settings.SLACK_PROXY )

# check for commits that need to be linted
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=True ):
  status = json.loads( commit.lint_results )
  done = True
  success = True
  for distro in status:
    if not status[ distro ].get( 'status', None ):
      logging.info( 'Queuing up Lint job for "%s", branch "%s", distro "%s"' % ( commit.project.name, commit.branch, distro ) )
      item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, 'lint', QUEUE_PRIORITY, commit )
      status[ distro ][ 'status' ] = 'building'

    done &= status[ distro ][ 'status' ] == 'done'
    success &= status[ distro ].get( 'success', False )

  commit.lint_results = json.dumps( status )

  if done:
    logging.info( 'Lint Complete for "%s", branch "%s"' % ( commit.project.name, commit.branch ) )
    commit.lint_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Lint for "%s", branch "%s" failed' % ( commit.project.name, commit.branch ) )
      commit.done_at = datetime.utcnow().replace( tzinfo=utc )
      slack.post_message( 'Lint for "%s", branch "%s" Failed.' % ( commit.project.name, commit.branch ), slack.ERROR )
      commit.project.postResults( commit.commit, commit.lint_results, None, None )
      commit.passed = False
    else:
      slack.post_message( 'Lint for "%s", branch "%s" Success.' % ( commit.project.name, commit.branch ), slack.SUCCESS )

  commit.save()

#check for commits that need testing
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=True ):
  status = json.loads( commit.test_results )
  done = True
  success = True
  for distro in status:
    if not status[ distro ].get( 'status', None ):
      logging.info( 'Queuing up Test job for "%s", branch "%s", distro "%s"' % ( commit.project.name, commit.branch, distro ) )
      item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, 'test', QUEUE_PRIORITY, commit )
      status[ distro ][ 'status' ] = 'building'

    done &= status[ distro ][ 'status' ] == 'done'
    success &= status[ distro ].get( 'success', False )

  commit.test_results = json.dumps( status )

  if done:
    logging.info( 'Test Complete for "%s", branch "%s"' % ( commit.project.name, commit.branch ) )
    commit.test_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Test for "%s", branch "%s" failed' % ( commit.project.name, commit.branch ) )
      commit.done_at = datetime.utcnow().replace( tzinfo=utc )
      slack.post_message( 'Test for "%s", branch "%s" Failed.' % ( commit.project.name, commit.branch ), slack.ERROR )
      commit.project.postResults( commit.commit, commit.lint_results, commit.test_results, None )
      commit.passed = False
    else:
      slack.post_message( 'Test for "%s", branch "%s" Success.' % ( commit.project.name, commit.branch ), slack.SUCCESS )
      commit.passed = True

  commit.save()

#check for commits that need building
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=False, build_at__isnull=True ):
  if commit.branch == 'master': # only build from master branch
    status = json.loads( commit.build_results )
    done = True
    success = True
    for target in status:
      for distro in status[ target ]:
        if not status[ target ][ distro ].get( 'status', None ):
          logging.info( 'Queuing up "%s" job for "%s", branch "%s", distro "%s"' % ( target, commit.project.name, commit.branch, distro ) )
          item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, target, QUEUE_PRIORITY, commit )
          status[ target ][ distro ][ 'status' ] = 'building'

        done &= status[ target ][ distro ][ 'status' ] == 'done'
        success &= status[ target ][ distro ].get( 'success', False )

      commit.build_results = json.dumps( status )

  else:
    done = True
    success = True

  if done:
    logging.info( 'Commit "%s" of "%s" branch "%s" Complete' % ( commit.commit, commit.project.name, commit.branch ) )
    commit.build_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.warning( 'Commit "%s" of "%s" branch "%s" Failed' % ( commit.commit, commit.project.name, commit.branch ) )
      slack.post_message( 'Commit "%s" of "%s", branch "%s" Failed.' % ( commit.commit, commit.project.name, commit.branch ), slack.ERROR )
      commit.built = False
    else:
      slack.post_message( 'Commit "%s" of "%s", branch "%s" Finished.' % ( commit.commit, commit.project.name, commit.branch ), slack.DONE )
      commit.built = True

    commit.done_at = datetime.utcnow().replace( tzinfo=utc )
    commit.project.postResults( commit.commit, commit.lint_results, commit.test_results, commit.build_results )

  commit.save()

os.unlink( PID_FILE )
logging.info( 'Done!' )
logging.shutdown()
sys.exit( 0 )
