#!/usr/bin/env python3
#
# recongnizer
#   Processes Records in the Commits table
#
#  Steps include linting, testing, then building
#

import os

os.environ.setdefault( "DJANGO_SETTINGS_MODULE", "mcp.settings" )

import sys
import logging
import json
from logging.handlers import SysLogHandler
from datetime import datetime
from django.utils.timezone import utc
from django.conf import settings

from mcp.Processor.models import QueueItem
from mcp.Project.models import Commit
from mcp.lib.Slack import Slack

PID_FILE = '/var/run/recoginzer.pid'
QUEUE_PRIORITY = 100

logging.basicConfig()
logger = logging.getLogger()
handler = SysLogHandler( address='/dev/log', facility=SysLogHandler.LOG_DAEMON )
handler.setFormatter( logging.Formatter( fmt='recognizer[%(process)d]: %(message)s' ) )
logger.addHandler( handler )
logging.info( 'Starting...' )
if '-v' in sys.argv:
  logger.setLevel( logging.DEBUG )
elif '-c' in sys.argv:
  logger.setLevel( logging.ERROR )
else:
  logger.setLevel( logging.INFO )

if os.path.exists( PID_FILE ):
  logging.error( 'pid file exists, bailing...' )
  sys.exit( 0 )

tmp = open( PID_FILE, 'w' )
tmp.write( '{0}\n'.format( os.getpid() ) )
tmp.close()

slack = Slack( 'recognizer', settings.SLACK_API_TOKEN, settings.SLACK_CHANNEL, settings.SITE_NAME, settings.SLACK_PROXY )

# check for commits that need to be linted
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=True ):
  status = json.loads( commit.lint_results )

  if not status:
    slack.post_message( 'No Lint for "{0}", branch "{1}".'.format( commit.project.name, commit.branch ), slack.INFO )
    commit.lint_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  done = True
  success = True
  for distro in status:
    if not status[ distro ].get( 'status', None ):
      logging.info( 'Queuing up Lint job for "{0}", branch "{1}", distro "{2}"'.format( commit.project.name, commit.branch, distro ) )
      try:
        item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, 'lint', QUEUE_PRIORITY, commit )
        status[ distro ][ 'status' ] = 'building'
      except Exception as e:
        status[ distro ][ 'status' ] = 'done'
        status[ distro ][ 'results' ] = 'Exception Queuing: "{0}"'.format( e )

    done &= status[ distro ][ 'status' ] == 'done'
    success &= status[ distro ].get( 'success', False )

  commit.lint_results = json.dumps( status )

  if done:
    logging.info( 'Lint Complete for "{0}", branch "{1}"'.format( commit.project.name, commit.branch ) )
    commit.lint_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Lint for "{0}", branch "{1}" failed'.format( commit.project.name, commit.branch ) )
      commit.done_at = datetime.utcnow().replace( tzinfo=utc )
      slack.post_message( 'Lint for "{0}", branch "{1}" Failed.'.format( commit.project.name, commit.branch ), slack.ERROR )
      commit.passed = False
      commit.postResults()
    else:
      slack.post_message( 'Lint for "{0}", branch "{1}" Success.'.format( commit.project.name, commit.branch ), slack.SUCCESS )

  commit.save()

# check for commits that need testing
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=True ):
  status = json.loads( commit.test_results )

  if not status:
    slack.post_message( 'No Test for "{0}", branch "{1}".'.format( commit.project.name, commit.branch ), slack.INFO )
    commit.test_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  done = True
  success = True
  for distro in status:
    if not status[ distro ].get( 'status', None ):
      logging.info( 'Queuing up Test job for "{0}", branch "{1}", distro "{2}"'.format( commit.project.name, commit.branch, distro ) )
      try:
        item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, 'test', QUEUE_PRIORITY, commit )
        status[ distro ][ 'status' ] = 'building'
      except Exception as e:
        status[ distro ][ 'status' ] = 'done'
        status[ distro ][ 'results' ] = 'Exception Queuing: "{0}"'.format( e )

    done &= status[ distro ][ 'status' ] == 'done'
    success &= status[ distro ].get( 'success', False )

  commit.test_results = json.dumps( status )

  if done:
    logging.info( 'Test Complete for "{0}", branch "{1}"'.format( commit.project.name, commit.branch ) )
    commit.test_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Test for "{0}", branch "{1}" failed'.format( commit.project.name, commit.branch ) )
      commit.done_at = datetime.utcnow().replace( tzinfo=utc )
      slack.post_message( 'Test for "{0}", branch "{1}" Failed.'.format( commit.project.name, commit.branch ), slack.ERROR )
      commit.passed = False
      commit.postResults()
    else:
      slack.post_message( 'Test for "{0}", branch "{1}" Success.'.format( commit.project.name, commit.branch ), slack.SUCCESS )
      commit.passed = True

  commit.save()

# check for commits that need building
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=False, build_at__isnull=True ):
  if commit.branch != 'master':  # only build from master branch
    commit.build_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  status = json.loads( commit.build_results )

  if not status:
    slack.post_message( 'No Build for "{0}".'.format( commit.project.name, slack.INFO ) )
    commit.build_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  done = True
  success = True
  for target in status:
    for distro in status[ target ]:
      if not status[ target ][ distro ].get( 'status', None ):
        logging.info( 'Queuing up "{0}" job for "{1}", branch "{2}", distro "{3}"'.format( target, commit.project.name, commit.branch, distro ) )
        try:
          item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, target, QUEUE_PRIORITY, commit )
          status[ target ][ distro ][ 'status' ] = 'building'
        except Exception as e:
          status[ target ][ distro ][ 'status' ] = 'done'
          status[ target ][ distro ][ 'results' ] = 'Exception Queuing: "{0}"'.format( e )

      done &= status[ target ][ distro ][ 'status' ] == 'done'
      success &= status[ target ][ distro ].get( 'success', False )

    commit.build_results = json.dumps( status )

  if done:
    logging.info( 'Build Complete for "{0}" of "{1}" branch "{2}" Complete'.format( commit.commit, commit.project.name, commit.branch ) )
    commit.build_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Build for "{0}" of "{1}" branch "{2}" Failed'.format( commit.commit, commit.project.name, commit.branch ) )
      commit.done_at = datetime.utcnow().replace( tzinfo=utc )
      slack.post_message( 'Build for "{0}" of "{1}", branch "{2}" Failed.'.format( commit.commit, commit.project.name, commit.branch ), slack.ERROR )
      commit.built = False
      commit.postResults()
    else:
      slack.post_message( 'Build for "{0}" of "{1}", branch "{2}" Finished.'.format( commit.commit, commit.project.name, commit.branch ), slack.SUCCESS )
      commit.built = True

  commit.save()

# check for commits that need docs
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=False, build_at__isnull=False, docs_at__isnull=True ):
  if commit.branch != 'master':  # only build docs from master branch
    commit.docs_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  status = json.loads( commit.docs_results )

  if not status:
    slack.post_message( 'No Docs for "{0}".'.format( commit.project.name ), slack.INFO )
    commit.docs_at = datetime.utcnow().replace( tzinfo=utc )
    commit.save()
    continue

  done = True
  success = True
  for distro in status:
    if not status[ distro ].get( 'status', None ):
      logging.info( 'Queuing up Docs job for "{0}", branch "{1}", distro "{2}"'.format( commit.project.name, commit.branch, distro ) )
      try:
        item = QueueItem.inQueueTarget( commit.project, commit.branch, False, distro, 'docs', QUEUE_PRIORITY, commit )
        status[ distro ][ 'status' ] = 'building'
      except Exception as e:
        status[ distro ][ 'status' ] = 'done'
        status[ distro ][ 'results' ] = 'Exception Queuing: "{0}"'.format( e )

    done &= status[ distro ][ 'status' ] == 'done'
    success &= status[ distro ].get( 'success', False )

  commit.docs_results = json.dumps( status )

  if done:  # failed doc building dosen't block anything, just make the comment and move on
    logging.info( 'Docs Complete for "{0}", branch "{1}"'.format( commit.project.name, commit.branch ) )
    commit.docs_at = datetime.utcnow().replace( tzinfo=utc )
    if not success:
      logging.info( 'Docs for "{0}", branch "{1}" failed'.format( commit.project.name, commit.branch ) )
      slack.post_message( 'Docs for "{0}", branch "{1}" Failed.'.format( commit.project.name, commit.branch ), slack.ERROR )
    else:
      slack.post_message( 'Docs for "{0}", branch "{1}" Success.'.format( commit.project.name, commit.branch ), slack.SUCCESS )

  commit.save()

# check for commits that are done
for commit in Commit.objects.filter( done_at__isnull=True, lint_at__isnull=False, test_at__isnull=False, build_at__isnull=False, docs_at__isnull=False ):
  slack.post_message( 'Commit "{0}" of "{1}", branch "{2}" Finished.'.format( commit.commit, commit.project.name, commit.branch ), slack.DONE )
  commit.done_at = datetime.utcnow().replace( tzinfo=utc )
  commit.postResults()
  commit.save()
  continue


os.unlink( PID_FILE )
logging.info( 'Done!' )
logging.shutdown()
sys.exit( 0 )
